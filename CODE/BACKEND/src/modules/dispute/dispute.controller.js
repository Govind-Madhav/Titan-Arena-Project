/**
 * Copyright (c) 2025 Titan E-sports. All rights reserved.
 * This code is proprietary and confidential.
 */

const { db } = require('../../db');
const { disputes, matches, users, tournaments, auditLogs } = require('../../db/schema');
const { eq, and, desc, count, sql } = require('drizzle-orm');
const { z } = require('zod');

// Create dispute
exports.createDispute = async (req, res) => {
    try {
        const schema = z.object({
            reason: z.string().min(10, 'Reason must be at least 10 characters'),
            evidenceUrl: z.string().url().optional()
        });

        const data = schema.parse(req.body);

        const matchResult = await db.select().from(matches).where(eq(matches.id, req.params.matchId)).limit(1);
        const match = matchResult[0];

        if (!match) {
            return res.status(404).json({ success: false, message: 'Match not found' });
        }

        if (match.status === 'DISPUTED') {
            return res.status(400).json({ success: false, message: 'Match already has an open dispute' });
        }

        const disputeId = await db.transaction(async (tx) => {
            const [result] = await tx.insert(disputes).values({
                matchId: match.id,
                raisedById: req.user.id,
                reason: data.reason,
                evidenceUrl: data.evidenceUrl || null,
                status: 'OPEN'
            });
            // In MySQL, result doesn't return key for UUIDs generated by DB often unless using returning() which is partial support.
            // But we used $defaultFn in schema, so we should probably generate ID here if we need it, or re-select.
            // Actually schema uses uuid(), relying on app or db?
            // Schema has `$defaultFn(() => crypto.randomUUID())` which means we rely on ORM to generate it if not provided.
            // Drizzle insert usually returns { insertId } for auto-inc. For UUIDs generated by client (defaultFn), we don't get it back easily without `returning` (PG only usually).
            // Better to let Drizzle handle it or pass ID.
            // Let's assume re-selection for now or ignore return data if not critical.
            // But the legacy code returned the dispute object. I'll just return basic success for now or the ID if I can capture it.
            // Wait, defaultFn runs on CLIENT side in Drizzle usually.

            await tx.update(matches)
                .set({ status: 'DISPUTED' })
                .where(eq(matches.id, match.id));

            return result.insertId; // Might be 0 for UUID
        });

        res.status(201).json({
            success: true,
            message: 'Dispute raised'
        });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return res.status(400).json({ success: false, message: 'Validation failed', errors: error.errors });
        }
        console.error('Create dispute error:', error);
        res.status(500).json({ success: false, message: 'Failed to create dispute' });
    }
};

// Get my disputes
exports.getMyDisputes = async (req, res) => {
    try {
        const result = await db.select({
            id: disputes.id,
            reason: disputes.reason,
            status: disputes.status,
            createdAt: disputes.createdAt,
            match: matches
        })
            .from(disputes)
            .leftJoin(matches, eq(disputes.matchId, matches.id))
            .where(eq(disputes.raisedById, req.user.id))
            .orderBy(desc(disputes.createdAt));

        // Grouping/Formatting if needed, but simple join return is fine for API usually
        // Drizzle joins return { dispute: ..., match: ... } structure by default if selected fully
        // But here I manually selected fields.
        // Let's stick to Drizzle's default join structure for cleaner manual mapping if needed.

        const formatted = await db.select()
            .from(disputes)
            .leftJoin(matches, eq(disputes.matchId, matches.id))
            .where(eq(disputes.raisedById, req.user.id))
            .orderBy(desc(disputes.createdAt));

        const data = formatted.map(row => ({
            ...row.dispute,
            match: row.match
        }));

        res.json({ success: true, data });
    } catch (error) {
        console.error('Get my disputes error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch disputes' });
    }
};

// Admin: List disputes
exports.listDisputes = async (req, res) => {
    try {
        const { status = 'OPEN', page = 1, limit = 20 } = req.query;
        const skip = (parseInt(page) - 1) * parseInt(limit);
        const take = parseInt(limit);

        const conditions = [];
        if (status) conditions.push(eq(disputes.status, status));

        const [results, totalResult] = await Promise.all([
            db.select({
                dispute: disputes,
                match: matches,
                tournament: { id: tournaments.id, name: tournaments.name },
                raisedBy: { id: users.id, username: users.username }
            })
                .from(disputes)
                .leftJoin(matches, eq(disputes.matchId, matches.id))
                .leftJoin(tournaments, eq(matches.tournamentId, tournaments.id))
                .leftJoin(users, eq(disputes.raisedById, users.id))
                .where(and(...conditions))
                .orderBy(desc(disputes.createdAt))
                .limit(take)
                .offset(skip),

            db.select({ count: count() }).from(disputes).where(and(...conditions))
        ]);

        const data = results.map(row => ({
            ...row.dispute,
            match: {
                ...row.match,
                tournament: row.tournament
            },
            raisedBy: row.raisedBy
        }));

        const total = totalResult[0]?.count || 0;

        res.json({
            success: true,
            data,
            pagination: { page: parseInt(page), limit: take, total }
        });
    } catch (error) {
        console.error('List disputes error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch disputes' });
    }
};

// Admin: Resolve dispute
exports.resolveDispute = async (req, res) => {
    try {
        const { resolution, overrideWinnerId } = req.body;

        if (!resolution) {
            return res.status(400).json({ success: false, message: 'Resolution is required' });
        }

        // Fetch dispute with match and tournament
        const rows = await db.select({
            dispute: disputes,
            match: matches,
            tournament: tournaments
        })
            .from(disputes)
            .innerJoin(matches, eq(disputes.matchId, matches.id))
            .innerJoin(tournaments, eq(matches.tournamentId, tournaments.id))
            .where(eq(disputes.id, req.params.id))
            .limit(1);

        if (!rows.length) {
            return res.status(404).json({ success: false, message: 'Dispute not found' });
        }
        const { dispute, match, tournament } = rows[0];

        await db.transaction(async (tx) => {
            // Update dispute
            await tx.update(disputes)
                .set({
                    status: 'RESOLVED',
                    resolution,
                    resolvedAt: new Date()
                })
                .where(eq(disputes.id, dispute.id));

            // Update match
            const matchUpdate = { status: 'COMPLETED' };
            if (overrideWinnerId) {
                if (tournament.type === 'SOLO') {
                    matchUpdate.winnerId = overrideWinnerId; // Check schema: matches.winnerId is generic?
                    // matches table has `winnerId`. Controller logic used matchUpdate.winnerUserId / winnerTeamId.
                    // Let's check schema: matches has `winnerId`. It seems `winnerId` holds either user or team ID.
                    // The legacy code distinguished winnerUserId vs winnerTeamId which implies schema divergence?
                    // Schema line 271: winnerId: varchar('winnerId', { length: 191 }),
                    // So it is just ONE column. The Legacy Code was trying to be too smart or I misread it.
                    // Legacy: if (solo) matchUpdate.winnerUserId = ... else matchUpdate.winnerTeamId = ...
                    // If schema only has `winnerId`, then Drizzle should just update `winnerId`.
                    matchUpdate.winnerId = overrideWinnerId;
                } else {
                    matchUpdate.winnerId = overrideWinnerId;
                }
            }

            await tx.update(matches)
                .set(matchUpdate)
                .where(eq(matches.id, dispute.matchId));

            // Audit log
            await tx.insert(auditLogs).values({
                adminId: req.user.id,
                userId: req.user.id,
                action: overrideWinnerId ? 'MATCH_RESULT_OVERRIDE' : 'DISPUTE_RESOLVED',
                targetId: dispute.id, // entity/entityId mismatch in legacy vs new. Schema has targetId.
                details: JSON.stringify({ matchId: dispute.matchId, resolution, overrideWinnerId })
            });
        });

        res.json({ success: true, message: 'Dispute resolved' });
    } catch (error) {
        console.error('Resolve dispute error:', error);
        res.status(500).json({ success: false, message: 'Failed to resolve dispute' });
    }
};
